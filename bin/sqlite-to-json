#!/usr/bin/env node

var co = require('co')
var fs = require('mz/fs')
var csv = require('csv')
var sqlite = require('co-sqlite3')

var path = require('path')

var args = process.argv.slice(2)
if (args.length < 1) {
	throw new Error('Must pass a file to sqlite-to-json')
}
var file = args[0]
var name = filename(file)

co(function * () {
	var db = yield sqlite(path.resolve(process.cwd(), file))

	var keys = ['urls', 'visits', 'meta', 'keyword_search_terms']
	var json = {}

	for (var key of keys) {
		var value = yield db.all(`SELECT * FROM ${key}`)
		json[key] = value.map(parsers[key])
	}

	return json.urls

}).then(data => {
	return Promise.resolve(JSON.stringify(data))
	// return new Promise((resolve, reject) => {
	// 	var columns = Object.keys(data[0])
	// 	csv.stringify(data, { headers: true, columns, delimiter: '	' }, (err, output) => {
	// 		if (err) return reject(err)
	// 		resolve(output)
	// 	})
	// })
})
.then(data => {
	return fs.writeFile(path.resolve(process.cwd(), `./db/${name}.json`), data)
}).then(() => {
	process.exit(0)
}).catch(err => {
	console.error(err.stack)
	process.exit(1)
})

/**
 * A list of parser functions, based on the key of Chrome's history DB
 */
var parsers = {
	meta: obj => obj,
	urls: obj => {
		obj['last_visit_time'] = parseDate(obj['last_visit_time'])
		return obj
	},
	keyword_search_terms: obj => obj,
	visits: obj => {
		obj['visit_time'] = parseDate(obj['visit_time'])
	},
	downloads: obj => obj
}

/**
 * Parses a date from a January 1, 1601 UTC microsecond timestamp to a UNIX timestamp
 * @see http://www.forensicswiki.org/wiki/Google_Chrome#History
 */
function parseDate (timestamp) {
	var v = (timestamp/1000000) - 11644473600
	return Math.floor(v * 1000)
}

function filename (p) {
	var pp = path.basename(p)
	return pp.substr(0, pp.lastIndexOf('.'))
}
